import (
	"encoding/base64"
	"encoding/json"
	"list"
	"strings"
)

input: {
	repoAddr: string
	repoPublicAddr: string
	managerAddr: string
	appId: string
	branch: string
	sshPrivateKey: string
	// TODO(gio): this should not be necessary as app.dev.username is autogenerated
	username?: string
}

_devVM: {}

if app.dev.enabled {
	input: {
		username?: string | *app.dev.username
		vpnAuthKey: string  @role(VPNAuthKey) @usernameField(username)
	}
	_devVM: {
		username: app.dev.username
		domain: global.domain
		vpn: {
			enabled: true
			loginServer: "https://headscale.\(global.domain)"
			authKey: input.vpnAuthKey
		}
		codeServerEnabled: true
		cpuCores: 1
		memory: "1Gi"
		cloudInit: {
			_loadEnvFile: "/home/\(username)/.dodo_env.sh"
			writeFiles: [{
				path: _loadEnvFile
				content: "source <(curl -fsSL \(input.managerAddr)/api/apps/\(input.appId)/branch/\(input.branch)/env-profile)"
				owner: "\(username):\(username)"
				permissions: "0700"
			},
			{
				path: "/home/\(username)/.bash_profile"
				content: "source \(_loadEnvFile)"
				owner: "\(username):\(username)"
				permissions: "0700"
			}]
			runCmd: list.Concat([[
				["sh", "-c", "chown \(username):\(username) /home/\(username)/.cache"],
				["sh", "-c", "GIT_SSH_COMMAND='ssh -i /home/\(username)/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=accept-new' git clone --branch \(input.branch) \(input.repoPublicAddr)/\(input.appId) /home/\(username)/code"],
				["sh", "-c", "chown -R \(username):\(username) /home/\(username)/code"],
				["sh", "-c", "chown -R \(username):\(username) /home/\(username)"],
	        ], app.vm.cloudInit.runCmd])
		}
	}
}

#AppIngress: {
	network: string
	subdomain: string
	auth: #Auth

	_network: networks[strings.ToLower(network)]
	baseURL: "https://\(subdomain).\(_network.domain)"
}

#Command: {
	bin: string
	args: [...string] | *[]
	env: [...string] | *[]
}

#DevDisabled: {
	enabled: false
}

#DevEnabled: {
	enabled: true
	username: string
}

#Dev: #DevEnabled | #DevDisabled

#VMCustomization: {
	cloudInit: #CloudInit
	env: [...string] | *[]
}

#AppTmpl: {
	type: string
	cluster?: string
	ingress: #AppIngress
	volumes: [...#volume]
	postgresql: [...#PostgreSQL]
	rootDir: string
	runConfiguration: [...#Command]
	dev: #Dev | *{ enabled: false }
	vm: #VMCustomization

	lastCmdEnv: [
		for v in volumes {
			"DODO_VOLUME_\(strings.ToUpper(v.name))=/dodo-volume/\(v.name)"
		}
		for v in postgresql {
			"DODO_POSTGRESQL_\(strings.ToUpper(v.name))_ADDRESS=postgres-\(v.name).\(release.namespace).svc.cluster.local"
		}
		for v in postgresql {
			"DODO_POSTGRESQL_\(strings.ToUpper(v.name))_USERNAME=postgres"
		}
		for v in postgresql {
			"DODO_POSTGRESQL_\(strings.ToUpper(v.name))_PASSWORD=postgres"
		}
		for v in postgresql {
			"DODO_POSTGRESQL_\(strings.ToUpper(v.name))_DATABASE=postgres"
		}
    ]

	...
}

envProfile: strings.Join(list.Concat([
	app.vm.env,
	[for e in app.lastCmdEnv { "export \(e)" }]
]), "\n")

// Go app

_goVer1220: "golang:1.22.0"
_goVer1200: "golang:1.20.0"

#GoAppTmpl: #AppTmpl & {
	type: _goVer1220 | _goVer1200
	run: string | *"main.go"
	port: int | *8080
	rootDir: _appDir

	lastCmdEnv: [...string]

	runConfiguration: [{
		bin: "/usr/local/go/bin/go",
		args: ["mod", "tidy"]
	}, {
		bin: "/usr/local/go/bin/go",
		args: ["build", "-o", ".app", run]
	}, {
		bin: ".app",
		env: lastCmdEnv
	}]
}

#GoApp1200: #GoAppTmpl & {
	type: _goVer1200
	vm: {
		env: [
			"export PATH=$PATH:/usr/local/go/bin"
	    ]
		cloudInit: runCmd: [
			["sh", "-c", "wget https://go.dev/dl/go1.20.linux-amd64.tar.gz -O /tmp/go.tar.gz"],
			["sh", "-c", "rm -rf /usr/local/go && tar -C /usr/local -xzf /tmp/go.tar.gz"],
			["sh", "-c", "rm /tmp/go.tar.gz"],
        ]
	}
}

#GoApp1220: #GoAppTmpl & {
	type: _goVer1220
}

#GoApp: #GoApp1200 | #GoApp1220

// Hugo app

_hugoLatest: "hugo:latest"

#HugoAppTmpl: #AppTmpl & {
	type: _hugoLatest
	ingress: #AppIngress
	port: int | *8080
	rootDir: _appDir

	lastCmdEnv: [...string]

	runConfiguration: [{
		bin: "/usr/bin/hugo",
	}, {
		bin: "/usr/bin/hugo",
		args: [
			"server",
			"--watch=false",
			"--bind=0.0.0.0",
			"--port=\(port)",
			"--baseURL=\(ingress.baseURL)",
			"--appendPort=false",
        ]
		env: lastCmdEnv
	}]
}

#HugoApp: #HugoAppTmpl

// PHP app

#PHPAppTmpl: #AppTmpl & {
	type: "php:8.2-apache"
	port: int | *80
	rootDir: "/var/www/html"

	lastCmdEnv: [...string]

	runConfiguration: [{
		bin: "/usr/local/bin/apache2-foreground",
		env: lastCmdEnv
	}]
}

#PHPApp: #PHPAppTmpl

#App: #GoApp | #HugoApp | #PHPApp

app: #App
_app: app

if !_app.dev.enabled {
	{
		if _app.cluster != _|_ {
			input: {
				appVPNAuthKey: string  @role(VPNAuthKey) @username(private-network-proxy)
			}
		}
		out: {
			ingress: {
				app: {
					network: networks[strings.ToLower(_app.ingress.network)]
					subdomain: _app.ingress.subdomain
					auth: _app.ingress.auth
					service: {
						name: "app-app"
						port: name: "app"
					}
				}
			}
			images: {
				app: {
					repository: "giolekva"
					name: "app-runner"
					tag: strings.Replace(_app.type, ":", "-", -1)
					pullPolicy: "Always"
				}
				"tailscale-proxy": {
					repository: "tailscale"
					name: "tailscale"
					tag: "v1.42.0"
					pullPolicy: "IfNotPresent"
				}
			}
			charts: {
				"access-secrets": {
					kind: "GitRepository"
					address: "https://code.v1.dodo.cloud/helm-charts"
					branch: "main"
					path: "charts/access-secrets"
				}
				app: {
					kind: "GitRepository"
					address: "https://code.v1.dodo.cloud/helm-charts"
					branch: "main"
					path: "charts/app-runner"
				}
			}
			helm: {
				if _app.cluster != _|_ {
					{
					"access-secrets": {
						chart: charts["access-secrets"]
						values: {
							serviceAccountName: "default"
						}
					}
					}
				}
				app: {
					chart: charts.app
					values: {
						image: {
							repository: images.app.fullName
							tag: images.app.tag
							pullPolicy: images.app.pullPolicy
						}
						// TODO(gio): install gvisor runtime during new remote cluster init
						if _app.cluster == _|_ {
							runtimeClassName: "untrusted-external" // TODO(gio): make this part of the infra config
						}
						if _app.cluster != _|_ {
							extraContainers: [{
								name: "proxy"
								image: images["tailscale-proxy"].fullNameWithTag
								env: [{
									name: "TS_AUTHKEY"
									value: input.appVPNAuthKey
								}, {
									name: "TS_HOSTNAME"
									value: "dodo-app-\(input.appId)"
								}, {
									name: "TS_EXTRA_ARGS"
									value: "--login-server=https://headscale.\(global.domain)"
								}]
						    }]
						}
						appPort: _app.port
						appDir: _app.rootDir
						appId: input.appId
						repoAddr: "\(input.repoPublicAddr)/\(input.appId)"
						sshPrivateKey: base64.Encode(null, input.sshPrivateKey)
						runCfg: base64.Encode(null, json.Marshal(_app.runConfiguration))
						managerAddr: input.managerAddr
						volumes: [
							for v in _app.volumes {
								name: v.name
								mountPath: "/dodo-volume/\(v.name)"
							}
					    ]
					}
				}
			}
		}
	}
}

if _app.dev.enabled {
	{
		out: {
			ingress: {
				app: {
					network: networks[strings.ToLower(_app.ingress.network)]
					subdomain: _app.ingress.subdomain
					auth: _app.ingress.auth
					service: {
						name: _vmName
						port: name: "web"
					}
				}
				code: {
					network: networks[strings.ToLower(_app.ingress.network)]
					subdomain: "code-\(_app.ingress.subdomain)"
					auth: enabled: false
					service: {
						name: _vmName
						port: name: _codeServerPortName
					}
				}
			}
		}
	}
}

_vmName: "\(input.appId)-\(input.branch)"

out: {
	if app.cluster != _|_ {
		cluster: clusterMap[strings.ToLower(app.cluster)]
	}
	volumes: {
		for v in app.volumes {
			"\(v.name)": v
		}
	}
	postgresql: {
		for v in app.postgresql {
			"\(v.name)": v
		}
	}
	vm: {
		"\(_vmName)": _devVM
	}
}

_appDir: "/dodo-app"
